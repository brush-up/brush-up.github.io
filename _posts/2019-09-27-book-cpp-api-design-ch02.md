---
title:  "[BOOK]C++ API 디자인 - CHAPTER 02 품질"
excerpt: "C++ API 디자인 - CHAPTER 02 품질"

categories:
  - Book
tags:
  - [Book, Programming]

toc: true
toc_sticky: true
 
date: 2019-09-27
last_modified_at: 2019-09-27

published: false
---

# CHAPTER 02 품질


* 2.2 구체적인 구현 숨기기
	* API를 만드는 가장 큰 목적은 영향없이 API 내부 로직을 변경할 수 있도록 구체적인 구현을 숨기는데 있다. 
* 2.2.1 물리적 은닉:선언 vs 정의
	* 공개된 인터페이스(.h) 로 부터 분리된 파일(.cpp)에 상세한 내부 로직을 구현하자.
* 2.2.2 논리적 은닉:캡슐화
	* public(모두 접근 가능), protected(자식 클래스 멤버만 접근 가능), private(클래스 자신의 멤버만 접근 가능)
* 2.2.3 멤버 변수 감추기
	* 멤버 변수를 직접 접근을 막음으로써 유효성 체크, 실제 필요한 순간 활용(연산 비용 절감), 캐싱  등등이 가능해진다.
	* 클래스 데이터 멤버는 항상 public, protected 가 아닌 private로 선언하자.
	* (성능관점에서 public 멤버에 직접접근하는 것이 2~3배 빠르게 동작하지만 주의깊게 인라인함수, 최적화된 컴파일러를 통하면 성능차이는 많이 줄어 들 것이다.)
* 2.2.4 메서드 구현 숨기기
	* 유지보수를 위해서 public 로 선언할 필요 없는 메소드는 public 선언을 하지 말자.
	* 절대로 비상수 포인터나 참조를 private 데이터 멤버로 리턴하지 않는다. 이것은 캡슐화를 어기는 행위이다.
	* 내부적으로 사용하는 기능을 private 메소드로 헤더 파일에 선언하기보다는 .cpp에 정적 함수로 선언하는 것이 더 좋다.
* 2.2.5 클래스 구현 숨기기


* 2.3 작게 완성하기
* 2.3.1 지나친 약속은 금지
	* API를 릴리즈 하고 사용하는 경우 새로운 기능 추가는 쉽지만 기존의 것을 지우는 일은 어려운 일이다. "만약 의심된다면 멈춰라"
	* API 는 최대한 단순해야 한다.
* 2.3.2 가상 함수의 추가는 신중하게
	* 가상함수 호출은 내부적으로 vtable 탐색을 통해서 처리해야 한다 . 그렇지 않다면 가상함수는 컴파일시에 처리될 것이다. 이래서 가상 함수 호출은 비 가상함수 호출 보다 느리다.
	* (자주 호출 되지 않거나, 중요한 역할을 처리하면 이런 오버헤드는 큰 문제가 안된다.)
	* 가상함수 를 사용하면 할수록 vtable을 가리키는 포인터 크기때문에 객체 크리도 비례해서 증가한다. 
	* 가상함수는 인라인이 될수 없다. 가상함수는 ㄹ너타임시 실행되는 반면 인라인은 컴파일 시 최적화가 진행되기 때문이다.(한편으로  컴파일러가 가상함수를 인라인으로 만드는 경우도 있다.)
	* 이미 클래스에 가상함수가 존재하면 소멸자는 항상 가상으로 선언해야 한다.  이래야 파생 클래스가 자원을 할당할때 그 자원을 해제할수 있다. 
	* 생성자나 호출자에서는 절대 가상 함수를 호출하지 않는다. 
	* 타당한 이유가 없다면 함수를 오버라이드 할수 없게 만든다.
* 2.3.3 편리한 API

* 2.4 쉬운 사용성
* 2.4.1 한눈에 들어오는
	* 축얀된 이름을 쓰지 말자
* 2.4.2 잘못 사용하기에도 어렵게
	* 코드 가독성을 위해 boolean 타입보다는 enum 타입을 사용하자
* 2.4.3 일관성 있는
	* 함수의 이름과 파라미터의 순서를 일관성 있게 하자 (ex. STL엔 모두 size를 제공한다.)
* 2.4.4 수직적인
	* API 어느 구현 코드를 변경한다해도 다른 API에는 영향을 미치지 않도록 한다.
	* 같은 정보가 2가지 이상의 방법으로 반복되지 않게 한다. 
	* 노출된는 개념에 중복된 의미가 있으면 안된다. 모든 중첩된 개념은 각각의 기반 컴포넌트로 분리해야한다.
* 2.4.5 견고한 자원 할당
	* RAII(resource acquisition is initialization)
	* 만약 API가 자원을 할당하고 해제한는 인터페이스를 제공하면, 자원 할당과 해제를 관리하는 클래스도 함께 제공해야 하며 이 클래스의 생성자에서 자원을 할당하고 소멸자에서 자원을 해제시켜 주어야 한다. 
* 2.4.6 플랫폼 독립성
	* 플랫폼 종속적인 #ifdef코드를 public 헤더 파일에 사용하는것은 안된다.
	* 좋은 API는 느슨한 연결과 높은 결합성을 보인다.


* 2.5 느슨한 연결
* 2.5.1 이름만을 사용한 연결
	* #include 문을 사용해서 클래스의 전체 선언을 참조할 필요가 없담녀 전방 선언을 사용해라.

```cpp
class A
class B
{
	public B ();
	
	private A* a;
}
```
* 2.5.2 클래스 연결 줄이기
* 2.5.3 의도적인 중복
	* 특수한 경우에는 데이터 중복이 클래스 간의 연결을 줄여줄 수 있다.
* 2.5.4 매니저 클래스
	* 매니저 클래스는 하위수준에 여러개의 클래스를 포함하면서 중재하며 하위 수준의 여러개의 클래스의 의존성을 줄이는데 사용된다. 하위 수준의 클래스를 캡슐화 함으로써 의존성을 줄일수 있다.
	![image]({{ site.url }}{{ site.baseurl }}/assets/images/2019-09-27-book-cpp-api-design-ch02-001.png)

	* 는 아래처럼 변경하자

	![image]({{ site.url }}{{ site.baseurl }}/assets/images/2019-09-27-book-cpp-api-design-ch02-002.png)
* 2.5.5 콜백과 옵저버, 알림
	* 콜백, 저수준의 코드가 고수준의 코드를 호출할때 콜백을 사용하면 의존성을 만들지 않기에 유용함.

	```cpp
	#include <string>
	class ModuleB
	{
	public:
	typedef void (*CallbackType)(const std::string &name, void *data);
	void SetCallback(CallbackType cb, void *data);
	. . .
	private:
	CallbackType mCallback;
	void *mClosure;
	};
	```
	* 이러면 이렇게 호출 가능하다

	```cpp
	if (mCallback)
	{
	(*mCallback)("Hello World", mClosure);
	}
	```
	* 옵저버, 중요해서 4장에서 자세히 설명할께

* 2.6 안정화와 문서화, 테스트
	* 잘 설계된 API는 안정적이어야하고 미래 증명적이어야 한다. API간 반듯이 변경되지 말아야하는건 아니고 이전버전과 다름 버전이 호환되지 않는 형태로 변경되어선 안된다라는 것을 의미한다.

