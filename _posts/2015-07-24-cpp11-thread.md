---
title:  "[C++]C++11, thread 샘플 정리"
excerpt: "C++11에 추가된 thread 를 맛보다."

categories:
  - Cpp
tags:
  - [Cpp, Programming]

toc: true
toc_sticky: true
 
date: 2015-07-16
last_modified_at: 2015-07-16
---

# intro

* C++11 에 thread 라이브러리가 지원되니 너무 편해졌다. 
* 기존엔 이런식으로 귀찮게 일일이 작업을 했었었는데, 표준으로 들어가버리니 일일이 신경안써도 되서 좋긴한데... 
```c++
#if defined(_WIN32) || defined(_WIN64)
        HANDLE threadID = (HANDLE)_beginthreadex(NULL, 0, InternalThreadProc, this, 0, NULL);
        if(NULL == threadID)
        {
            //error
        }
#else
        pthread_t threadID;
        int ret = pthread_create(&threadID, NULL, InternalThreadProc, this);
 
        if(0 != ret)
        {
            //error
        }
#endif
```



# sample
* std::thread 생성자는 대략 이런식으로 생겼고.
```c++
class thread
    {    // class for observing and managing threads
public:
    class id;
 
    typedef void *native_handle_type;
 
    thread() _NOEXCEPT
        {    // construct with no thread
        _Thr_set_null(_Thr);
        }
 
    template<class _Fn,
        class... _Args>
        explicit thread(_Fn&& _Fx, _Args&&... _Ax)
        {    // construct with _Fx(_Ax...)
        _Launch(&_Thr,
             _STD bind(_Decay_copy(_STD forward<_Fn>(_Fx)),
                _Decay_copy(_STD forward<_Args>(_Ax))...));
        }
```
* 각종 생성 샘플은 이정도로
```c++
#include  <thread>
class TEST_CLASS
{
public:
    void member1_of_class(int args)
    {
        std::thread thread03(&TEST_CLASS::member2_of_class, this, args, args+3);
        thread03.join();
    };
 
    void member2_of_class(int args1, int args2)
    {
        std::cout << "TEST_CLASS::member2_of_class: " << args1 << ", " << args2  << std::endl;
    };
};
void thread02(int arg1)
{
    std::thread::id thread_id = std::this_thread::get_id();
    for (int i = arg1; i < 5; i++)
    {
        std::cout << "thread02 [" << thread_id << "]: " << i << std::endl;
    
    }
}
void test_thread()
{
    std::thread::id thread_id_main = std::this_thread::get_id();
    std::cout << "thread main :" << thread_id_main << std::endl;
 
    //case1. lambda 방식으로
    std::thread thread1([](){ 
        std::thread::id thread_id_01 = std::this_thread::get_id();
        for (int i = 0; i < 3; i++)
        {
            std::cout << "thread01 [" << thread_id_01 << "]: " << i << std::endl;
        }
    });
    //------------------------------------------------------
    // detach나 join으로 thread 리소스를 정리할수있다.
    // detach 했으면 굳이 join 부르지 않아도 되는데, 더이상 thread를 관리하지 못함.
    //------------------------------------------------------
    //Separates the thread of execution from the thread object - http://en.cppreference.com/w/cpp/thread/thread/detach
    thread1.detach();
 
    //join 할수 있는지 확인하자..
    if (true == thread1.joinable())
    {
        //thread 가 종료할때까지 대기.
        thread1.join();
    }
 
    //case2.
    int inputArgs = 2;
    std::thread thread2(thread02, inputArgs);
    std::thread::id thread_id_02 = thread2.get_id();
    if (thread2.joinable())
    {
        std::cout << "thread02 ["<< thread_id_02 << "] join" << std::endl;
        thread2.join();//thread 가 종료할때까지 대기.
    }

    //case3. 
    TEST_CLASS test_class;
    test_class.member1_of_class(3);
}
```
