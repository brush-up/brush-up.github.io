---
title:  "[BOOK]C++ API 디자인 - CHAPTER 04 설계  "
excerpt: "C++ API 디자인 - CHAPTER 04 설계  "

categories:
  - Book
tags:
  - [Book, Programming]

toc: true
toc_sticky: true
 
date: 2019-09-27
last_modified_at: 2019-09-27

published: true
---
# CHAPTER 04 설계

* 4.1 좋은 설계를 위한 사례
* 4.1.1 기술적 부채의 증가
	* 기술적 부채의 중가를 고민하자
	* "..처음코드를 작성하는 것은 빚을 지는 것과 같다. 그리고 코드를 개선하는 것은 빚을 갚는 활동이다..."
	* "... 그러다 결론엔 완성도 낮은 코드로 인해 전체 엔지니어링 조직은 빚더미에 놓인다."
	* "언제나 문제는 제품 출시일 때문에 발생한다"
* 4.1.2 부채 상환
	* 결과적으로 회사는 채무상태에 놓이게 되고 새로운 기능을 제공하기 보단 기존의 레거시 코드를 포함 전체적인 시스템 유지보수에 더 많은 시간을 투자한다. 이를 위해 
	* 차세대라는 이름의 프로젝트를 시작한다.
* 4.1.3 멀리 보는 설계 
* 4.2 기능적 요구사항 수집
* 4.2.1 기능적 요구사항
* 4.2.2 기능적 요구사항의 예 
* 4.2.3 요구사항 유지보수

* 4.3 유즈 케이스 생성
* 4.3.1 유즈 케이스 개발
* 4.3.2 유즈 케이스 템플릿 사용
* 4.3.3 좋은 유즈 케이스 작성
* 4.3.4 요구사항과 애자일 개발

* 4.4 API 설계 요소

* 4.5 아키텍쳐 설계
* 4.5.1 아키텍쳐 수립
* 4.5.2 아키텍쳐의 제약사향
* 4.5.3 주요 추상화 객체 식별
* 4.5.4 핵심 객체 생성
* 4.5.5 아키텍처 관점 패턴
* 4.5.6 아키텍처 논의

* 4.6 클래스 설계
* 4.6.1 객체 지향 개념
* 4.6.2 클래스 설계의 선택사항
	* const와 explict의 사용 - 할수 있는 만큼 인자와 리턴 값, 메서드를 const 로 정의라하. 단일 파라미터를 갖는 생성자의 예상치 못한 타입 형 변환 오류를 피하기 위해 explict를 사용하자
	* Friend의 사용 - Friend는 클래스 캡슐화를 방해하고 일반적으로 좋지 못한 설계를 대표한다. 최후의 상황에서만 사용하자
* 4.6.3 상속 사용
	* 적합한 경우에만 상속을 사용한다.
	* 깊은 상속 트리는 피한다(2~3단계 이상의 상속은 이미 너무 큰 복잡성을 지니고 있다.)
	* 서브 클래스에서 구현 코드를 제공하도록 순수 가상 멤버 함수를 사용한다.
	* 기존의 인터페이스에 새로운 순수 가상함수를 추가하지 않는다. 
	* 과도한 확장 설계는 피한다.
* 4.6.4 리스코브 대리 원칙
* 4.6.5 개발 / 폐쇄 원칙
* 4.6.6 데메테르의 법
* 4.6.7 클래스 이름

* 4.7 함수 설계
* 4.7.1 함수 설계의 선택사항
* 4.7.2 함수 이름

* 4.7.3 함수 파라미터
* 4.7.4 예외 처리
